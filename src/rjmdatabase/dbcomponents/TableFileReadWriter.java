package rjmdatabase.dbcomponents;

import rjmdatabase.fileutils.FileUtil;

import java.io.File;
import java.io.IOException;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.StringJoiner;

/**
 * A utility class that reads and writes Tables to files.
 * @author Rjmcf
 */
public class TableFileReadWriter
{
    // The String used to separate fields in files.
    private static final String FIELD_SEPARATOR = String.valueOf((char)0x1F);
    // The extension added to filenames.
    private static final String FILE_EXT = ".rjmTable";

    /**
     * Gets the name of the Table from the supplied file name.
     * @param  fName The name of the file in the form <tableName>.<extension>
     * @return       The Table name or null if the file is of the form .<extension>
     *               This file has probably been generated by the file system and
     *               should be disregarded.
     */
    static String getTableNameFromFileName(String fName)
    {
        String[] parts = fName.split("\\.");
        if (parts.length != 2)
            throw new IllegalArgumentException(String.format("File name %s must be in form <tableName>.<extension>", fName));
        if (parts[0].equals(""))
            return null;
        if (!("." + parts[1]).equals(FILE_EXT))
            throw new IllegalArgumentException("Invalid file extension ." + parts[1] + " for table files");

        return parts[0];
    }

    /**
     * Deletes the table file if it exists.
     * @param tableName     The name of the Table whose file we're deleting.
     * @param parentDirPath The folder containing the table file.
     */
    static void deleteTableFile(String tableName, String parentDirPath)
    {
        File tableFile = new File(parentDirPath + tableName + FILE_EXT);
        FileUtil.deleteFileIfExists(tableFile);
    }

    /**
     * Writes the given tableData to a file.
     * @param  tableData     The table data to write.
     * @param  parentDirPath The folder in which the file should be saved.
     * @throws IOException   if an error occurred during writing.
     */
    static void writeToFile(String tableName, String[][] tableData, String parentDirPath) throws IOException
    {
        // The lines to write.
        String[] lines = new String[tableData.length];
        StringJoiner joiner = new StringJoiner(FIELD_SEPARATOR);

        // Build the line to print for each row.
        for (int row = 0; row < tableData.length; row++)
        {
            String[] rowFields = tableData[row];
            joiner = new StringJoiner(FIELD_SEPARATOR);
            for (int f = 0; f < rowFields.length; f++)
            {
                // We convert to hex to allow strange characters in these fields.
                joiner.add(convertStringToHex(rowFields[f]));
            }
            lines[row] = joiner.toString();
        }

        String filePath = parentDirPath + tableName + FILE_EXT;
        FileUtil.writeFile(filePath, lines);
    }

    /**
     * Reads a table from a file, using the chosen method.
     * @param  name        The name of the table to be read.
     * @return             The Table instance that has been loaded.
     * @throws IOException If an io exception occurred.
     */
    static Table readFromFile(String name, String parentDirPath) throws IOException
    {
        ArrayList<String> lines = FileUtil.readFile(parentDirPath + name + FILE_EXT);
        String[][] tableData = new String[lines.size()][];
        String line;
        for (int row = 0; row < lines.size(); row++)
        {
            line = lines.get(row);
            tableData[row] = line.split(FIELD_SEPARATOR);
            for (int col = 0; col < tableData[row].length; col++)
                tableData[row][col] = convertHexToString(tableData[row][col]);
        }
        return Table.createTableFromData(name, tableData);
    }

    private static String convertHexToString(String h)
    {
        // TODO update Java and use HexFormat.of().parseHex(s)

        int len = h.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(h.charAt(i), 16) << 4)
                    + Character.digit(h.charAt(i+1), 16));
        }
        return new String(data, FileUtil.ENCODING);
    }

    private static String convertStringToHex(String s)
    {
        byte[] stringBytes = s.getBytes(FileUtil.ENCODING);
        String result = String.format("%x", new BigInteger(1, stringBytes));
        // Remember to add a leading "0" if we need it.
        return result.length() % 2 == 0 ? result : "0" + result;
    }
}
