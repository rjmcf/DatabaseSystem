package rjmdatabase.dbcomponents;

import rjmdatabase.fileutils.FileUtil;
import java.io.IOException;
import java.io.File;
import java.io.FileNotFoundException;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.StringJoiner;
import javax.xml.bind.DatatypeConverter;

/**
 * A utility class that reads and writes Tables to files. A Singleton class.
 * @author Rjmcf
 */
public class TableFileReadWriter
{
    private static TableFileReadWriter instance;

    // The String used to separate fields in files.
    private static final String FIELD_SEPARATOR = String.valueOf((char)0x1F);

    static final String FILE_EXT = ".rjmTable";

    /**
     * Gets the name of the Table from the supplied file name.
     * @param  fName The name of the file in the form <tableName>.<extension>
     * @return       The Table name or null if the file is of the form .<extension>
     *               This file has probably been generated by the file system and
     *               should be disregarded.
     */
    static String getTableNameFromFileName(String fName)
    {
        String[] parts = fName.split("\\.");
        if (parts.length != 2)
            throw new IllegalArgumentException("File name " + fName + " must be in form <tableName>.<extension>");
        if (parts[0].equals(""))
            return null;
        if (!("." + parts[1]).equals(FILE_EXT))
            throw new IllegalArgumentException("Invalid file extension ." + parts[1] + " for table files");

        return parts[0];
    }

    static void deleteTableFile(String tableName, String parentDirPath)
    {
        File tableFile = new File(parentDirPath + tableName + FILE_EXT);
        FileUtil.deleteFileIfExists(tableFile);
    }

    /**
     * Writes the given table to a file, using the chosen method.
     * @param  t           The Table to write.
     * @throws IOException If an io exception occurred.
     */
    static void writeToFile(Table t, String parentDirPath) throws IOException
    {
        String[][] tableData = t.getTableData();

        // The lines to write.
        String[] lines = new String[tableData.length];
        StringJoiner joiner = new StringJoiner(FIELD_SEPARATOR);

        // Build the line to print for each row.
        for (int row = 0; row < tableData.length; row++)
        {
            String[] rowFields = tableData[row];
            joiner = new StringJoiner(FIELD_SEPARATOR);
            for (int f = 0; f < rowFields.length; f++)
            {
                // We convert to hex to allow strange characters in these fields.
                joiner.add(convertStringToHex(rowFields[f]));
            }
            lines[row] = joiner.toString();
        }

        String filePath = parentDirPath + t.getName() + FILE_EXT;
        FileUtil.writeFile(filePath, lines);
    }

    /**
     * Reads a table from a file, using the chosen method.
     * @param  name        The name of the table to be read.
     * @return             The Table instance that has been loaded.
     * @throws IOException If an io exception occurred.
     */
    static Table readFromFile(String name, String parentDirPath) throws IOException
    {
        ArrayList<String> lines = FileUtil.readFile(parentDirPath + name + FILE_EXT);
        String[][] tableData = new String[lines.size()][];
        for (int row = 0; row < lines.size(); row++)
        {
            tableData[row] = lines.get(row).split(FIELD_SEPARATOR);
            for (int col = 0; col < tableData[row].length; col++)
                tableData[row][col] = convertHexToString(tableData[row][col]);
        }
        return Table.createTableFromData(name, tableData);
    }

    private static String convertHexToString(String h)
    {
        byte[] bytes = DatatypeConverter.parseHexBinary(h);
        return new String(bytes, FileUtil.ENCODING);
    }

    private static String convertStringToHex(String s)
    {
        String result = String.format("%x", new BigInteger(1, s.getBytes(FileUtil.ENCODING)));
        // Remember to add a leading "0" if we need it.
        return result.length() % 2 == 0 ? result : "0" + result;
    }
}
